## 1. 어차피 목표는 programming in general이다. Java에서는 Object라는 최상위 class가 있다. 이것을 이용하면 되는데 구테여 generic data type을 만들어 사용 하는 이유를 설명하라.

모든 클래스는 Object 클래스를 상속받기 때문에 객체를 Object 타입으로 받으면 그 어떤 타입이라도 받을 수 있습니다. 
하지만 그럴경우, 예를 들어서 Integer 타입으로 선언된 list에 String을 넣을 경우 잘못된 타입캐스팅이 이루어짐과 동시에 타입캐스팅이 이루어졌다는 
오류가 런타임때 발생하게 됩니다. 
하지만 컴파일 시점에서는 어떤 오류도 발생하지 않아 문제가 될 수 있습니다. 
그렇기 때문에 Object만을 이용해서 객체를 생성하는 것은 어떤 타입으로 형변환 할 수 있는지 조차 모호한 경우도 많기 때문에 잠재적인 오류를 가지고 있는 
매우 좋지 않은 방식입니다. 
위 예시에 경우 문제를 해결하기 위해 list에 대한 타입을 나눠 listForInteger와 listForString을 만들고 각각의 클래스에 메서드를 구현할 수 있는데 이럴 경우 
각 클래스마다 메서드를 일일이 구현해주어야 하기 때문에 코드의 중복이 생기기 시작합니다. 
메서드 파라미터 타입과 리턴 타입이 서로 달라서 인터페이스나 상속을 통해 해결할 수도 없다. 
이같은 문제들 때문에 제네릭 데이터 타입을 이용하는데, 제네릭 데이터 타입을 이용해 만들경우 컴파일 타임에 타입을 체크해서 객체 자체의 타입 안전성을 
높일 수 있으며 개발자가 의도하지 않은 타입의 객체가 저장되는 것을 방지할 수 있고 객체의 기존타입에서 다른 타입으로 캐스팅 되어 발생하는 
오류를 줄일 수 있습니다. 
또한 형 변환의 번거로움을 줄일 수 있습니다.

## 2. 교과서 93쪽 2.7장에서는 무슨 문제가 있고, 어떻게 하라는 이야기 인가? 설명하라.

2.7 예제에서 bag = new T[capacity];는 제네릭 타입을 사용하여 bag 객체를 생성하는데, 제네릭 타입을 사용해서 array를 생성하는 것이 불가능하기 때문에 
문제가 발생합니다. 
그리고 bag = new Object[capacity];에서도 Object타입과 제네릭 타입의 array가 호환되지 않기 때문에 해당 할당문에서도 문제가 발생합니다. 
따라서 bag = (T[])new Object[capacity];로 Object타입을 캐스팅함으로써 할당합니다. 
이 경우 컴파일러에서 사용자에게 캐스팅에 대해서 안전한지 검사하기 위해 unchecked-cast warning을 출력하게 되는데, 
캐스팅에 대해서 문제가 없기 때문에 @SuppressWarnings("unchecked")를 작성함으로써 컴파일러가 해당 warning에 대해 무시하게 만들어줍니다.